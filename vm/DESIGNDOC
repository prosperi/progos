            +---------------------------+
            |         ProgOS            |
            | PROJECT 2: VIRTUAL MEMORY |
            |      DESIGN DOCUMENT      |
            +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Jakob Gruber <jakob.gruber@gmail.com>
Nico Schaumberger <e1025736@student.tuwien.ac.at>
Mino Sharkhawy <mino.sharkhawy@student.tuwien.ac.at>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			PAGE TABLE MANAGEMENT
			=====================
---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TBD

---- IMPLEMENTATION ----
>> A2: Describe how you implemented lazy page loading. How do you
>> determine the file and file offset corresponding to a virtual
>> address?

A physical frame of memory is only allocated to a page in the page_fault() handler, provided that the requested address is valid. The load_segment() function called from the load() function during the initialization of the process only writes the virtual addresses to the supplemental page table, from where they will be faulted to physical memory at runtime.

Both the file and the file offset corresponding to a virtual memory address is stored in the SPT entry of the page. The offset of a particular address can be calculated by adding the offset of the address from the start of the page to the offset of the page as a whole.

---- SYNCHRONIZATION ----
>> A3: How do you deal with or prevent page faults in file system
>> routines. Argue why your solution is deadlock free.

File system routines: TBD

The solution is deadlock free because the synchronization is done via one global filesystem lock. This way, only one process can access the file system at the same time, and this process does not attempt to aquire any other locks while holding the filesystem lock.


			    STACK GROWTH
			    ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TBD

---- IMPLEMENTATION ----
>> B2: Describe how you integrated the (potentially growing) stack segment
>> into your page table management implementation.

The setup_stack() function creates and immediately loads one stack page at STACK_PAGE_START. After that, additional stack pages are created and loaded by the page_fault() handler as needed. The stack is also prevented from growing below PHYS_BASE - STACK_MAX_SIZE, to eliminate the possibility of the stack segment overwriting other segments.

---- ALGORITHMS ----
>> B3: Explain how you detect a page fault which should trigger a
>> stack growth. What asssumptions are needed for your implementation
>> to work?

If a page fault is detected at between the current stackpointer and the current stackpointer minus STACK_MAX_OFFSET, then a stack growth is assumed. This implementation assumes that there will be no valid stack access below STACK_MAX_OFFSET of the current stackpointer, because that would be considered an error.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TBD

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.

In this implementation, the mmap-syscall reads the desired address for the mapping from userspace. The content of the file is then stored in a series of pages based on this initial address. The parameters needed to describe memory mapped files are integrated in the SPT entry, and set to NULL for all pages that are not part of a memory mapped file.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

The SPT in our case is implemented as a hashmap. If the hash of a page about to be used for mapping a file already exists in our hashmap, we know that a collision has occured and can retern the appropriate error code.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

TBD

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
